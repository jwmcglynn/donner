#!/usr/bin/env python3
"""Generate CMakeLists.txt files for Donner libraries using bazel query."""

from __future__ import annotations

import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple

# Use bzlmod-aware queries since this repository relies on MODULE.bazel. The workspace file is
# intentionally omitted.
BAZEL_QUERY_PREFIX = ["bazel", "query", "--enable_bzlmod", "--keep_going"]

# Stores the link type (e.g., "INTERFACE", "PUBLIC") for CMake targets generated by this script.
CMAKE_GENERATED_TARGETS_LINK_TYPE: Dict[str, str] = {}

# Mapping of known Bazel labels for external/third-party dependencies to their CMake target names
# This might need adjustment based on exact bazel query output for external repos.
KNOWN_BAZEL_TO_CMAKE_DEPS: Dict[str, str] = {
    "//third_party/frozen:frozen": "frozen",
    "@entt//:entt": "EnTT::EnTT",
    "@com_google_googletest//:gtest": "gtest",
    "@nlohmann_json//:json": "nlohmann_json::nlohmann_json",
    "@rules_cc//cc/runfiles:runfiles": "rules_cc_runfiles",
    "@stb//:image": "stb_image",
    "@stb//:image_write": "stb_image_write",
    "//third_party/public-sans:public-sans": "public_sans_font",
}


def query_labels(attr: str, target: str, *, relative_to: str) -> List[str]:
    expr = f"labels({attr}, {target})"
    out = subprocess.check_output(BAZEL_QUERY_PREFIX + [expr], text=True, stderr=subprocess.DEVNULL)
    pkg = target.split(":")[0].removeprefix("//")
    prefix = f"//{pkg}:"
    results = []
    for line in out.splitlines():
        if not line.startswith(prefix):
            continue
        label = line[len(prefix) :]
        full = Path(pkg, label)
        results.append(str(full.relative_to(relative_to)))
    return results


def query_cc_libraries(pkg: str) -> List[str]:
    expr = f"kind(cc_library, //{pkg}:*)"
    out = subprocess.check_output(
        BAZEL_QUERY_PREFIX + [expr], text=True, stderr=subprocess.DEVNULL
    )
    libs = []
    for line in out.splitlines():
        libs.append(line.split(":")[1])
    return libs


def cmake_target_name(pkg: str, lib: str) -> str:
    pkg_rel = pkg.removeprefix("donner/").replace("/", "_")
    base = f"donner_{pkg_rel}"
    pkg_last = pkg_rel.split("_")[-1]
    if lib == pkg_last:
        return base
    if lib.startswith(pkg_last + "_"):
        return f"{base}_{lib[len(pkg_last)+1:]}"
    if lib.endswith("_" + pkg_last):
        return f"{base}_{lib[:-len(pkg_last)-1]}"
    return f"{base}_{lib}"


def query_direct_deps_labels(target_label: str) -> List[str]:
    """Queries bazel for the labels listed in the 'deps' attribute of a given target."""
    # Example: labels(deps, //donner/svg:svg_core)
    expr = f"labels(deps, {target_label})"
    try:
        out = subprocess.check_output(
            BAZEL_QUERY_PREFIX + [expr], text=True, stderr=subprocess.PIPE
        )
        # Filter out empty lines or lines that are not valid labels (e.g. warnings from --keep_going)
        return [
            line.strip()
            for line in out.splitlines()
            if line.strip() and (line.strip().startswith("//") or line.strip().startswith("@"))
        ]
    except subprocess.CalledProcessError as e:
        print(
            f"Warning: Bazel query for labels(deps, {target_label}) failed: {e.stderr.strip()}"
        )
        return []


def generate_root() -> None:
    path = Path("CMakeLists.txt")
    with path.open("w") as f:
        f.write("cmake_minimum_required(VERSION 3.20)\n")
        f.write("project(donner LANGUAGES CXX)\n\n")
        f.write("set(CMAKE_CXX_STANDARD 20)\n")
        f.write("set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n")
        f.write("include(FetchContent)\n")
        f.write("option(DONNER_BUILD_TESTS \"Build Donner tests\" OFF)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  entt\n")
        f.write("  GIT_REPOSITORY https://github.com/skypjack/entt.git\n")
        f.write("  GIT_TAG        v3.13.2\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(entt)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  googletest\n")
        f.write("  GIT_REPOSITORY https://github.com/google/googletest.git\n")
        f.write("  GIT_TAG        v1.17.0\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(googletest)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  nlohmann_json\n")
        f.write("  GIT_REPOSITORY https://github.com/nlohmann/json.git\n")
        f.write("  GIT_TAG        v3.12.0\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(nlohmann_json)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  rules_cc\n")
        f.write("  GIT_REPOSITORY https://github.com/bazelbuild/rules_cc.git\n")
        f.write("  GIT_TAG        0.1.1\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(rules_cc)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  skia\n")
        f.write("  GIT_REPOSITORY https://github.com/google/skia.git\n")
        f.write("  GIT_TAG        d945cbcbbb5834245256e883803c2704f3a32e18\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(skia)\n")
        f.write(
            "execute_process(COMMAND python3 bin/fetch-gn "
            "WORKING_DIRECTORY ${skia_SOURCE_DIR})\n"
        )
        f.write(
            "execute_process(COMMAND python3 tools/git-sync-deps "
            "WORKING_DIRECTORY ${skia_SOURCE_DIR})\n"
        )
        f.write(
            "execute_process(COMMAND ${skia_SOURCE_DIR}/bin/gn gen "
            "${skia_SOURCE_DIR}/out/cmake --ide=json --json-ide-script="
            "${skia_SOURCE_DIR}/gn/gn_to_cmake.py "
            "--args=skia_use_gl=false "
            "WORKING_DIRECTORY ${skia_SOURCE_DIR})\n"
        )
        f.write("set(BUILD_TESTING OFF CACHE BOOL \"\" FORCE)\n")
        f.write("add_subdirectory(${skia_SOURCE_DIR}/out/cmake skia)\n")
        f.write("set(BUILD_TESTING ON CACHE BOOL \"\" FORCE)\n\n")
        f.write("if(DONNER_BUILD_TESTS)\n")
        f.write("  enable_testing()\n")
        f.write("endif()\n\n")

        f.write("execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink\n")
        f.write("  ${rules_cc_SOURCE_DIR} ${CMAKE_BINARY_DIR}/rules_cc\n")
        f.write("  RESULT_VARIABLE _ignored)\n")
        f.write(
            "add_library(rules_cc_runfiles ${rules_cc_SOURCE_DIR}/cc/runfiles/runfiles.cc)\n"
        )
        f.write("target_include_directories(rules_cc_runfiles PUBLIC ${CMAKE_BINARY_DIR})\n\n")

        f.write("# STB libraries\n")
        f.write("add_library(stb_image third_party/stb/stb_image_impl.cc third_party/stb/stb_image.h)\n")
        f.write("target_include_directories(stb_image PUBLIC ${PROJECT_SOURCE_DIR}/third_party)\n")
        f.write("set_target_properties(stb_image PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n")
        CMAKE_GENERATED_TARGETS_LINK_TYPE["stb_image"] = "PUBLIC" # It has a source file

        f.write("add_library(stb_image_write third_party/stb/stb_image_write_impl.cc third_party/stb/stb_image_write.h)\n")
        f.write("target_include_directories(stb_image_write PUBLIC ${PROJECT_SOURCE_DIR}/third_party)\n")
        f.write("set_target_properties(stb_image_write PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n")
        CMAKE_GENERATED_TARGETS_LINK_TYPE["stb_image_write"] = "PUBLIC" # It has a source file

        f.write("add_subdirectory(third_party/public-sans)\n")
        f.write("\n")

        f.write("add_subdirectory(donner/base)\n")
        f.write("add_subdirectory(third_party/frozen)\n")
        f.write("add_subdirectory(donner/css)\n")
        f.write("add_subdirectory(donner/svg)\n")


def write_library(f, name: str, srcs: List[str], hdrs: List[str]) -> None:
    global CMAKE_GENERATED_TARGETS_LINK_TYPE
    if srcs:
        CMAKE_GENERATED_TARGETS_LINK_TYPE[name] = "PUBLIC"  # Normal libraries are linked with PUBLIC
        f.write(f"add_library({name}\n")
        for path in srcs + hdrs:
            f.write(f"  {path}\n")
        f.write(")\n")
        f.write(
            f"target_include_directories({name} PUBLIC ${{PROJECT_SOURCE_DIR}})\n"
        )
        f.write(
            f"set_target_properties({name} PROPERTIES CXX_STANDARD 20 "
            "CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n"
        )
        f.write(f"target_compile_options({name} PRIVATE -fno-exceptions)\n")
    else:
        CMAKE_GENERATED_TARGETS_LINK_TYPE[name] = "INTERFACE"
        f.write(f"add_library({name} INTERFACE)\n")
        if hdrs:
            f.write(f"target_sources({name} INTERFACE\n")
            for p in hdrs:
                f.write(f"  {p}\n")
            f.write(")\n")
        f.write(
            f"target_include_directories({name} INTERFACE ${{PROJECT_SOURCE_DIR}})\n"
        )
        f.write(f"target_compile_options({name} INTERFACE -fno-exceptions)\n")


def generate_public_sans() -> None:
    cmake = Path("third_party/public-sans/CMakeLists.txt")
    with cmake.open("w") as f:
        f.write("##\n")
        f.write("## Generated by tools/cmake/gen_cmakelists.py.\n")
        f.write("## NOTE: Do not edit this file directly, edit gen_cmakelists.py instead\n")
        f.write("##\n\n")
        f.write("find_package(Python3 REQUIRED)\n")
        f.write("set(PUBLIC_SANS_FONT ${PROJECT_SOURCE_DIR}/third_party/public-sans/PublicSans-Medium.otf)\n")
        f.write("set(PUBLIC_SANS_OUT ${CMAKE_CURRENT_BINARY_DIR}/embed_resources)\n")
        f.write("file(MAKE_DIRECTORY ${PUBLIC_SANS_OUT})\n")
        f.write("add_custom_command(\n")
        f.write("  OUTPUT ${PUBLIC_SANS_OUT}/PublicSans_Medium_otf.cpp ${PUBLIC_SANS_OUT}/PublicSansFont.h\n")
        f.write("  COMMAND ${Python3_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/embed_resources.py --out ${PUBLIC_SANS_OUT} --header PublicSansFont.h kPublicSansMediumOtf=${PUBLIC_SANS_FONT}\n")
        f.write("  DEPENDS ${PUBLIC_SANS_FONT} ${PROJECT_SOURCE_DIR}/tools/embed_resources.py\n")
        f.write("  COMMENT \"Embedding Public Sans\"\n")
        f.write("  VERBATIM\n")
        f.write(")\n")
        f.write("add_library(public_sans_font ${PUBLIC_SANS_OUT}/PublicSans_Medium_otf.cpp)\n")
        f.write("target_include_directories(public_sans_font PUBLIC ${PUBLIC_SANS_OUT})\n")
        f.write("set_target_properties(public_sans_font PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n")
        f.write("target_compile_options(public_sans_font PRIVATE -fno-exceptions)\n")


def generate_base() -> None:
    pkg = Path("donner/base")
    libs = query_cc_libraries("donner/base")

    utils_hdrs = query_labels(
        "hdrs", "//donner/base:base_test_utils", relative_to="donner/base"
    )
    testdata = query_labels(
        "srcs", "//donner/base:base_tests_testdata", relative_to="donner/base"
    )
    tests = {
        "base_tests": query_labels(
            "srcs", "//donner/base:base_tests", relative_to="donner/base"
        ),
        "base_tests_ndebug": query_labels(
            "srcs", "//donner/base:base_tests_ndebug", relative_to="donner/base"
        ),
        "rcstring_tests_with_exceptions": query_labels(
            "srcs",
            "//donner/base:rcstring_tests_with_exceptions",
            relative_to="donner/base",
        ),
    }

    out = pkg / "CMakeLists.txt"
    with out.open("w") as f:
        f.write("##\n")
        f.write("## Generated by tools/cmake/gen_cmakelists.py.\n")
        f.write("## NOTE: Do not edit this file directly, edit gen_cmakelists.py instead\n")
        f.write("##\n\n")

        for lib in libs:
            if lib in {"base_utils_h_ndebug", "base_test_utils"}:
                continue
            srcs = query_labels("srcs", f"//donner/base:{lib}", relative_to="donner/base")
            hdrs = query_labels("hdrs", f"//donner/base:{lib}", relative_to="donner/base")
            target = cmake_target_name("donner/base", lib)
            write_library(f, target, srcs, hdrs)
            if lib == "base":
                f.write("target_link_libraries(donner_base PUBLIC EnTT::EnTT)\n")

        f.write("\nif(DONNER_BUILD_TESTS)\n")
        if utils_hdrs:
            f.write("  add_library(donner_base_test_utils INTERFACE\n")
            for p in utils_hdrs:
                f.write(f"    {p}\n")
            f.write("  )\n")
            f.write(
                "  target_include_directories(donner_base_test_utils INTERFACE "
                "${PROJECT_SOURCE_DIR})\n"
            )
            f.write(
                "  target_link_libraries(donner_base_test_utils INTERFACE gtest gmock "
                "rules_cc_runfiles)\n"
            )

        for name, src in tests.items():
            if not src:
                continue
            f.write(f"\n  add_executable({name}\n")
            
            for p in src:
                if p.endswith("Runfiles_tests.cc"):
                    # Skip the Runfiles tests, they do not currently work in CMake
                    continue
                f.write(f"    {p}\n")

            f.write("  )\n")
            if name == "base_tests_ndebug":
                f.write("  target_compile_definitions(base_tests_ndebug PRIVATE NDEBUG)\n")
            if name == "rcstring_tests_with_exceptions":
                f.write(
                    "  target_compile_options(rcstring_tests_with_exceptions "
                    "PRIVATE -fexceptions)\n"
                )
            else:
                f.write(f"  target_compile_options({name} PRIVATE -fno-exceptions)\n")
            f.write(f"  target_link_libraries({name} PRIVATE donner_base gtest_main gmock_main")
            if utils_hdrs:
                f.write(" donner_base_test_utils")
            f.write(")\n")
            f.write(f"  add_test(NAME {name} COMMAND {name})\n")
            f.write(
                f"  set_tests_properties({name} PROPERTIES ENVIRONMENT "
                f"\"RUNFILES_DIR=${{PROJECT_SOURCE_DIR}}\")\n"
            )

        if testdata:
            f.write("\n  file(COPY\n")
            for p in testdata:
                f.write(f"    {p}\n")
            f.write("  DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/tests/testdata)\n")
        f.write("endif()\n")


def generate_css() -> None:
    pkg = Path("donner/css")
    libs = []
    libs += [
        ("donner/css", name)
        for name in query_cc_libraries("donner/css")
        if name != "selector_test_utils"
    ]
    libs += [
        ("donner/css/parser", name)
        for name in query_cc_libraries("donner/css/parser")
    ]

    selector_utils_hdrs = query_labels(
        "hdrs", "//donner/css:selector_test_utils", relative_to="donner/css"
    )

    css_tests = query_labels("srcs", "//donner/css:css_tests", relative_to="donner/css")
    css_parser_tests = query_labels(
        "srcs", "//donner/css/parser:parser_tests", relative_to="donner/css"
    )
    css_parsing_tests = query_labels(
        "srcs", "//donner/css/parser:css_parsing_tests", relative_to="donner/css"
    )

    # TODO: Re-enable parsing tests, currently they are disabled since they require bazel runfiles
    # to be set up correctly, which is not the case in CMake.
    css_parsing_tests = None

    out = pkg / "CMakeLists.txt"
    with out.open("w") as f:
        f.write("##\n")
        f.write("## Generated by tools/cmake/gen_cmakelists.py.\n")
        f.write("## NOTE: Do not edit this file directly, edit gen_cmakelists.py instead\n")
        f.write("##\n\n")

        for p, lib in libs:
            srcs = query_labels("srcs", f"//{p}:{lib}", relative_to="donner/css")
            hdrs = query_labels("hdrs", f"//{p}:{lib}", relative_to="donner/css")
            target = cmake_target_name(p, lib)
            write_library(f, target, srcs, hdrs)
            # Link dependencies based on their determined type
            # This part needs to be more dynamic like in generate_svg if these targets have deps
            # For now, handling specific known links for css libraries:
            # Determine the linking scope for the current target
            # If 'target' itself is INTERFACE, all its deps must be linked with INTERFACE scope.
            # Otherwise, use PUBLIC scope for its dependencies.
            current_target_type = CMAKE_GENERATED_TARGETS_LINK_TYPE.get(target, "PUBLIC")
            link_scope_for_target_deps = "INTERFACE" if current_target_type == "INTERFACE" else "PUBLIC"

            if target == "donner_css_core": # This is a PUBLIC library
                f.write(f"target_link_libraries(donner_css_core {link_scope_for_target_deps} donner_base)\n")
                f.write(f"target_link_libraries(donner_css_core {link_scope_for_target_deps} donner_base_element)\n")
                f.write(f"target_link_libraries(donner_css_core {link_scope_for_target_deps} donner_base_xml_qualified_name)\n")
                f.write(f"target_link_libraries(donner_css_core {link_scope_for_target_deps} frozen)\n")
            elif target == "donner_css_parser": # This is a PUBLIC library
                f.write(f"target_link_libraries(donner_css_parser {link_scope_for_target_deps} donner_css_core)\n")
                f.write(f"target_link_libraries(donner_css_parser {link_scope_for_target_deps} donner_base)\n")
                f.write(f"target_link_libraries(donner_css_parser {link_scope_for_target_deps} donner_base_parser)\n")
            elif target == "donner_css": # This is a PUBLIC library
                f.write(f"target_link_libraries(donner_css {link_scope_for_target_deps} donner_css_core)\n")
                f.write(f"target_link_libraries(donner_css {link_scope_for_target_deps} donner_css_parser)\n")

        f.write("\nif(DONNER_BUILD_TESTS)\n")
        if selector_utils_hdrs:
            f.write("  add_library(donner_css_selector_test_utils INTERFACE\n")
            for p in selector_utils_hdrs:
                f.write(f"    {p}\n")
            f.write("  )\n")
            f.write(
                "  target_compile_options(donner_css_selector_test_utils INTERFACE "
                "-fno-exceptions)\n"
            )
            f.write(
                "  target_include_directories(donner_css_selector_test_utils INTERFACE "
                "${PROJECT_SOURCE_DIR})\n"
            )
            f.write(
                "  target_link_libraries(donner_css_selector_test_utils INTERFACE gtest)\n"
            )

        if css_tests:
            f.write("\n  add_executable(css_tests\n")
            for p in css_tests:
                f.write(f"    {p}\n")
            f.write("  )\n")
            f.write("  target_compile_options(css_tests PRIVATE -fno-exceptions)\n")
            f.write(
                "  target_link_libraries(css_tests PRIVATE donner_css_parser "
                "donner_css_core donner_css_selector_test_utils gtest_main "
                "donner_base_test_utils donner_base_element_fake)\n"
            )
            f.write("  add_test(NAME css_tests COMMAND css_tests)\n")
            f.write(
                "  set_tests_properties(css_tests PROPERTIES ENVIRONMENT "
                "\"RUNFILES_DIR=${PROJECT_SOURCE_DIR}\")\n"
            )

        if css_parser_tests:
            f.write("\n  add_executable(css_parser_tests\n")
            for p in css_parser_tests:
                f.write(f"    {p}\n")
            f.write("  )\n")
            f.write("  target_compile_options(css_parser_tests PRIVATE -fno-exceptions)\n")
            f.write(
                "  target_link_libraries(css_parser_tests PRIVATE donner_css_parser "
                "donner_css_selector_test_utils gtest_main donner_base_test_utils)\n"
            )
            f.write("  add_test(NAME css_parser_tests COMMAND css_parser_tests)\n")
            f.write(
                "  set_tests_properties(css_parser_tests PROPERTIES ENVIRONMENT "
                "\"RUNFILES_DIR=${PROJECT_SOURCE_DIR}\")\n"
            )

        if css_parsing_tests:
            f.write("\n  add_executable(css_parsing_tests\n")
            for p in css_parsing_tests:
                f.write(f"    {p}\n")
            f.write("  )\n")
            f.write("  target_compile_options(css_parsing_tests PRIVATE -fno-exceptions)\n")
            f.write(
                "  target_link_libraries(css_parsing_tests PRIVATE donner_css_parser "
                "gtest_main donner_base_test_utils "
                "nlohmann_json::nlohmann_json)\n"
            )
            f.write("  add_test(NAME css_parsing_tests COMMAND css_parsing_tests)\n")
            f.write(
                "  set_tests_properties(css_parsing_tests PROPERTIES ENVIRONMENT "
                "\"RUNFILES_DIR=${PROJECT_SOURCE_DIR}\")\n"
            )
            f.write("  file(COPY\n")
            for name in [
                "component_value_list.json",
                "declaration_list.json",
                "one_component_value.json",
                "one_declaration.json",
                "one_rule.json",
                "rule_list.json",
                "stylesheet.json",
            ]:
                f.write(f"    ${{PROJECT_SOURCE_DIR}}/third_party/css-parsing-tests/{name}\n")
            f.write("  DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/css-parsing-tests)\n")
        f.write("endif()\n")


def generate_svg() -> None:
    pkg = Path("donner/svg")
    packages = [
        "donner/svg",
        "donner/svg/components",
        "donner/svg/components/filter",
        "donner/svg/components/layout",
        "donner/svg/components/paint",
        "donner/svg/components/resources",
        "donner/svg/components/shadow",
        "donner/svg/components/style",
        "donner/svg/components/shape",
        "donner/svg/components/text",
        "donner/svg/core",
        "donner/svg/graph",
        "donner/svg/parser",
        "donner/svg/properties",
        "donner/svg/resources",
        "donner/svg/renderer",
    ]

    libs: List[Tuple[str, str]] = []
    for p in packages:
        libs.extend([(p, name) for name in query_cc_libraries(p)])

    seen = set()

    out = pkg / "CMakeLists.txt"
    with out.open("w") as f:
        f.write("##\n")
        f.write("## Generated by tools/cmake/gen_cmakelists.py.\n")
        f.write("## NOTE: Do not edit this file directly, edit gen_cmakelists.py instead\n")
        f.write("##\n\n")

        for p, lib in libs:
            target = cmake_target_name(p, lib)
            if target in seen:
                continue
            seen.add(target)
            srcs = query_labels("srcs", f"//{p}:{lib}", relative_to="donner/svg")
            hdrs = query_labels("hdrs", f"//{p}:{lib}", relative_to="donner/svg")
            write_library(f, target, srcs, hdrs)

            # Automatically link dependencies based on Bazel's direct 'deps' attribute
            bazel_full_target = f"//{p}:{lib}"
            direct_deps_labels = query_direct_deps_labels(bazel_full_target)
            
            cmake_dep_targets = []
            for dep_label in direct_deps_labels:
                if dep_label == bazel_full_target:  # Skip self-dependency
                    continue

                mapped_dep_target = None
                if dep_label.startswith("//donner/"):
                    # Internal Donner library
                    parts = dep_label.removeprefix("//").split(":", 1)
                    dep_pkg = parts[0]
                    if len(parts) > 1:
                        dep_name = parts[1]
                    else:
                        # If no explicit target name (e.g., "//donner/base"),
                        # assume target name is the last part of the package path.
                        dep_name = Path(dep_pkg).name
                    
                    mapped_dep_target = cmake_target_name(dep_pkg, dep_name)

                elif dep_label in KNOWN_BAZEL_TO_CMAKE_DEPS:
                    mapped_dep_target = KNOWN_BAZEL_TO_CMAKE_DEPS[dep_label]
                else:
                    # Heuristics for common external libraries if they appear in direct deps
                    # (less likely if BUILD files use aliases, but good to have)
                    if dep_label.startswith("@entt//"): # Bazel label for entt
                        mapped_dep_target = "EnTT::EnTT" # CMake target for entt
                    elif dep_label.startswith("@com_github_google_googletest//:gtest") or \
                         dep_label.startswith("@googletest//:gtest"): # Common gtest labels
                        mapped_dep_target = "gtest"
                    elif dep_label.startswith("@com_github_google_googletest//:gmock") or \
                         dep_label.startswith("@googletest//:gmock"): # Common gmock labels
                        mapped_dep_target = "gmock"
                    elif dep_label.startswith("@com_github_nlohmann_json//:json") or \
                         dep_label.startswith("@nlohmann_json//:json"): # Common nlohmann_json labels
                        mapped_dep_target = "nlohmann_json::nlohmann_json"
                    elif dep_label.startswith("@rules_cc//cc/runfiles"):
                        mapped_dep_target = "rules_cc_runfiles"
                    # else:
                    #    print(f"Note: Unhandled Bazel dependency label '{dep_label}' for CMake target '{target}'")

                if mapped_dep_target and mapped_dep_target != target: # Avoid self-linking
                    if mapped_dep_target not in cmake_dep_targets:
                        cmake_dep_targets.append(mapped_dep_target)
            
            # Determine the linking scope for the current target's dependencies.
            # If 'target' itself is INTERFACE, all its deps must be linked with INTERFACE scope.
            # Otherwise, use PUBLIC scope as a general default for its dependencies.
            current_target_link_scope = "INTERFACE" if CMAKE_GENERATED_TARGETS_LINK_TYPE.get(target) == "INTERFACE" else "PUBLIC"

            unique_linked_deps = set()
            deps_to_link_str_list = []
            for dep_cmake_name in cmake_dep_targets:
                if dep_cmake_name not in unique_linked_deps:
                    deps_to_link_str_list.append(dep_cmake_name)
                    unique_linked_deps.add(dep_cmake_name)
            
            if deps_to_link_str_list:
                all_deps_str = " ".join(deps_to_link_str_list)
                f.write(f"target_link_libraries({target} {current_target_link_scope} {all_deps_str})\n")

            # Special case for Skia renderer
            if target == "donner_svg_renderer_skia":
                # donner_svg_renderer_skia is a PUBLIC library. Skia is an external PUBLIC lib.
                # This ensures 'skia' is linked if not already covered by the general dep logic.
                if "skia" not in unique_linked_deps: # Avoid duplicate linking
                    f.write(f"target_link_libraries(donner_svg_renderer_skia PUBLIC skia)\n")
                # Skia headers live relative to skia_SOURCE_DIR which is defined
                # by FetchContent. Propagate these include directories so that
                # RendererSkia.cc can include files like include/core/SkBitmap.h.
                f.write(
                    "target_include_directories(donner_svg_renderer_skia PUBLIC ${skia_SOURCE_DIR})\n"
                )
            elif target == "donner_svg_renderer_skia_deps":
                if sys.platform == "darwin":
                    f.write(
                        "target_compile_definitions(donner_svg_renderer_skia_deps INTERFACE DONNER_USE_CORETEXT)\n"
                    )
                elif sys.platform.startswith("linux"):
                    f.write(
                        "target_compile_definitions(donner_svg_renderer_skia_deps "
                        "INTERFACE DONNER_USE_FREETYPE_WITH_FONTCONFIG)\n"
                    )
                    f.write(
                        "target_link_libraries(donner_svg_renderer_skia_deps INTERFACE fontconfig)\n"
                    )
                else:
                    f.write(
                        "target_compile_definitions(donner_svg_renderer_skia_deps INTERFACE DONNER_USE_FREETYPE)\n"
                    )

def generate_base_support() -> None:
    packages = [
        "donner/base/parser",
        "donner/base/element",
        "donner/base/xml",
    ]
    libs: List[Tuple[str, str]] = []
    for p in packages:
        libs.extend([(p, name) for name in query_cc_libraries(p)])

    path = Path("donner/base") / "CMakeLists.txt"
    with path.open("a") as f:
        f.write("\n# Additional libraries\n")
        for pkg, lib in libs:
            srcs = query_labels("srcs", f"//{pkg}:{lib}", relative_to="donner/base")
            hdrs = query_labels("hdrs", f"//{pkg}:{lib}", relative_to="donner/base")
            target = cmake_target_name(pkg, lib)
            write_library(f, target, srcs, hdrs)

            # Determine the linking scope for the current target's dependencies.
            # If 'target' itself is INTERFACE, all its deps must be linked with INTERFACE scope.
            # Otherwise, use PUBLIC scope as a general default for its dependencies.
            current_target_link_scope = "INTERFACE" if CMAKE_GENERATED_TARGETS_LINK_TYPE.get(target) == "INTERFACE" else "PUBLIC"

            if target == "donner_base_parser":
                f.write(f"target_link_libraries(donner_base_parser {current_target_link_scope} donner_base)\n")
            elif target == "donner_base_parser_line_offsets":
                f.write(f"target_link_libraries(donner_base_parser_line_offsets {current_target_link_scope} donner_base)\n")
            elif target == "donner_base_element_fake":
                f.write(f"target_link_libraries(donner_base_element_fake {current_target_link_scope} gtest)\n")
            elif target == "donner_base_xml":
                f.write(f"target_link_libraries(donner_base_xml {current_target_link_scope} donner_base)\n")
            elif target == "donner_base_xml_qualified_name":
                f.write(f"target_link_libraries(donner_base_xml_qualified_name {current_target_link_scope} donner_base)\n")


def main() -> None:
    generate_root()
    generate_base()
    generate_base_support()
    generate_public_sans()
    generate_css()
    generate_svg()


if __name__ == "__main__":
    main()
