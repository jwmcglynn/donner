#!/usr/bin/env python3
"""Generate CMakeLists.txt files for Donner libraries using bazel query."""

from __future__ import annotations

import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple, DefaultDict

# Use bzlmod-aware queries since this repository relies on MODULE.bazel. The workspace file is
# intentionally omitted.
BAZEL_QUERY_PREFIX = ["bazel", "query", "--enable_bzlmod", "--keep_going"]

# Stores the link type for CMake targets generated by this script.
# INTERFACE | PUBLIC | EXECUTABLE
CMAKE_GENERATED_TARGETS_LINK_TYPE: Dict[str, str] = {}

# Mapping of known Bazel labels for external/third-party dependencies to their CMake target names
# This might need adjustment based on exact bazel query output for external repos.
KNOWN_BAZEL_TO_CMAKE_DEPS: Dict[str, str] = {
    "@com_google_absl//absl/debugging:failure_signal_handler": "absl::failure_signal_handler",
    "@com_google_absl//absl/debugging:symbolize": "absl::symbolize",
    "@com_google_gtest//:gtest_main": "gmock_main",
    "@com_google_gtest//:gtest": "gmock",
    "@entt//:entt": "EnTT::EnTT",
    "@entt//src:entt": "EnTT::EnTT",
    "@frozen//:frozen": "frozen",
    "@nlohmann_json//:json": "nlohmann_json::nlohmann_json",
    "@rules_cc//cc/runfiles:runfiles": "rules_cc_runfiles",
    "@stb//:image_write": "stb_image_write",
    "@stb//:image": "stb_image",
    "//third_party/public-sans:public-sans": "public_sans_font",
}


def query_labels(attr: str, target: str, *, relative_to: str) -> List[str]:
    expr = f"labels({attr}, {target})"
    out = subprocess.check_output(BAZEL_QUERY_PREFIX + [expr], text=True, stderr=subprocess.DEVNULL)
    pkg = target.split(":")[0].removeprefix("//")
    prefix = f"//{pkg}:"
    results = []
    for line in out.splitlines():
        if not line.startswith(prefix):
            continue
        label = line[len(prefix) :]
        full = Path(pkg, label)
        results.append(str(full.relative_to(relative_to)))
    return results


def query_cc_targets() -> List[Tuple[str, str]]:
    """Return (kind, label) for every cc_* target under //â€¦, excluding externals."""
    kinds = ("donner_cc_library", "cc_library", "cc_binary", "cc_test")
    out: List[Tuple[str, str]] = []
    for kind in kinds:
        expr = f"kind({kind}, //...)"
        try:
            result = subprocess.check_output(
                BAZEL_QUERY_PREFIX + [expr], text=True, stderr=subprocess.DEVNULL
            )
        except subprocess.CalledProcessError as e:
            print(
                f"Warning: Bazel query for kind({kind}) failed: {e}\n"
                "Please ensure Bazel is installed and in PATH.",
                file=sys.stderr,
            )
            return []
        for line in result.splitlines():
            line = line.strip()
            if not line or line.startswith("@"):  # skip externals
                continue
            out.append((kind, line))
    return out

# Packages whose CMake build is provided manually or by FetchContent and therefore
# must *not* be auto-generated here.
SKIPPED_PACKAGES = {
    "",  # skip root package; handled by generate_root()
    "third_party/frozen",
    "third_party/stb",
    "third_party/public-sans",
    "examples",
}


def cmake_target_name(pkg: str, lib: str) -> str:
    pkg_rel = pkg.removeprefix("donner/").replace("/", "_")
    # Handle the root package ("//:donner") which results in an empty pkg_rel
    if not pkg_rel:
        return "donner" if lib == "donner" else f"donner_{lib}"

    base = f"donner_{pkg_rel}"
    pkg_last = pkg_rel.split("_")[-1]
    if lib == pkg_last:
        return base
    if lib.startswith(pkg_last + "_"):
        return f"{base}_{lib[len(pkg_last)+1:]}"
    if lib.endswith("_" + pkg_last):
        return f"{base}_{lib[:-len(pkg_last)-1]}"
    return f"{base}_{lib}"


def query_deps(target_label: str) -> List[str]:
    """Queries bazel for the transitive dependencies of a given target."""
    # Example: deps(//donner/svg:svg_core)
    expr = f"kind(\"cc_library\", deps({target_label}))"
    try:
        out = subprocess.check_output(
            BAZEL_QUERY_PREFIX + [expr], text=True, stderr=subprocess.PIPE
        )
        # Filter out empty lines or lines that are not valid labels (e.g. warnings from --keep_going)
        return [
            line.strip()
            for line in out.splitlines()
            if line.strip()
            and (line.strip().startswith("//") or line.strip().startswith("@"))
            and line.strip() != target_label
        ]
    except subprocess.CalledProcessError as e:
        print(
            f"Warning: Bazel query for labels(deps, {target_label}) failed: {e.stderr.strip()}"
        )
        return []


def generate_root() -> None:
    path = Path("CMakeLists.txt")
    with path.open("w") as f:
        f.write("cmake_minimum_required(VERSION 3.20)\n")
        f.write("project(donner LANGUAGES CXX)\n\n")
        f.write("set(CMAKE_CXX_STANDARD 20)\n")
        f.write("set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n")
        f.write("include(FetchContent)\n")
        f.write("option(DONNER_BUILD_TESTS \"Build Donner tests\" OFF)\n\n")
        f.write("set(BUILD_GMOCK ON CACHE BOOL \"\" FORCE)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  entt\n")
        f.write("  GIT_REPOSITORY https://github.com/skypjack/entt.git\n")
        f.write("  GIT_TAG        v3.13.2\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(entt)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  googletest\n")
        f.write("  GIT_REPOSITORY https://github.com/google/googletest.git\n")
        f.write("  GIT_TAG        v1.17.0\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(googletest)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  nlohmann_json\n")
        f.write("  GIT_REPOSITORY https://github.com/nlohmann/json.git\n")
        f.write("  GIT_TAG        v3.12.0\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(nlohmann_json)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  absl\n")
        f.write("  GIT_REPOSITORY https://github.com/abseil/abseil-cpp.git\n")
        f.write("  GIT_TAG        20250512.0\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(absl)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  rules_cc\n")
        f.write("  GIT_REPOSITORY https://github.com/bazelbuild/rules_cc.git\n")
        f.write("  GIT_TAG        0.1.1\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(rules_cc)\n\n")

        f.write("FetchContent_Declare(\n")
        f.write("  skia\n")
        f.write("  GIT_REPOSITORY https://github.com/google/skia.git\n")
        f.write("  GIT_TAG        d945cbcbbb5834245256e883803c2704f3a32e18\n")
        f.write(")\n")
        f.write("FetchContent_MakeAvailable(skia)\n")
        f.write(
            "execute_process(COMMAND python3 bin/fetch-gn "
            "WORKING_DIRECTORY ${skia_SOURCE_DIR})\n"
        )
        f.write(
            "execute_process(COMMAND python3 tools/git-sync-deps "
            "WORKING_DIRECTORY ${skia_SOURCE_DIR})\n"
        )
        f.write(
            "execute_process(COMMAND ${skia_SOURCE_DIR}/bin/gn gen "
            "${skia_SOURCE_DIR}/out/cmake --ide=json --json-ide-script="
            "${skia_SOURCE_DIR}/gn/gn_to_cmake.py "
            "--args=skia_use_gl=false "
            "WORKING_DIRECTORY ${skia_SOURCE_DIR})\n"
        )
        f.write("set(BUILD_TESTING OFF CACHE BOOL \"\" FORCE)\n")
        f.write("add_subdirectory(${skia_SOURCE_DIR}/out/cmake skia)\n")
        f.write("set(BUILD_TESTING ON CACHE BOOL \"\" FORCE)\n\n")
        f.write("if(DONNER_BUILD_TESTS)\n")
        f.write("  enable_testing()\n")
        f.write("endif()\n\n")

        f.write("execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink\n")
        f.write("  ${rules_cc_SOURCE_DIR} ${CMAKE_BINARY_DIR}/rules_cc\n")
        f.write("  RESULT_VARIABLE _ignored)\n")
        f.write(
            "add_library(rules_cc_runfiles ${rules_cc_SOURCE_DIR}/cc/runfiles/runfiles.cc)\n"
        )
        f.write("target_include_directories(rules_cc_runfiles PUBLIC ${CMAKE_BINARY_DIR})\n\n")

        f.write("# STB libraries\n")
        f.write("add_library(stb_image third_party/stb/stb_image_impl.cc third_party/stb/stb_image.h)\n")
        f.write("target_include_directories(stb_image PUBLIC ${PROJECT_SOURCE_DIR}/third_party)\n")
        f.write("set_target_properties(stb_image PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n")
        CMAKE_GENERATED_TARGETS_LINK_TYPE["stb_image"] = "PUBLIC" # It has a source file

        f.write("add_library(stb_image_write third_party/stb/stb_image_write_impl.cc third_party/stb/stb_image_write.h)\n")
        f.write("target_include_directories(stb_image_write PUBLIC ${PROJECT_SOURCE_DIR}/third_party)\n")
        f.write("set_target_properties(stb_image_write PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n")
        CMAKE_GENERATED_TARGETS_LINK_TYPE["stb_image_write"] = "PUBLIC" # It has a source file

        f.write("add_subdirectory(third_party/public-sans)\n")
        f.write("\n")

        f.write("add_subdirectory(donner/base)\n")
        f.write("add_subdirectory(third_party/frozen)\n")
        f.write("add_subdirectory(donner/css)\n")
        f.write("add_subdirectory(donner/svg)\n")
        f.write("\n")
        f.write("add_subdirectory(examples)\n")


def write_library(f, name: str, srcs: List[str], hdrs: List[str]) -> None:
    global CMAKE_GENERATED_TARGETS_LINK_TYPE
    if srcs:
        CMAKE_GENERATED_TARGETS_LINK_TYPE[name] = "PUBLIC"  # Normal libraries are linked with PUBLIC
        f.write(f"add_library({name}\n")
        for path in srcs + hdrs:
            f.write(f"  {path}\n")
        f.write(")\n")
        f.write(
            f"target_include_directories({name} PUBLIC ${{PROJECT_SOURCE_DIR}})\n"
        )
        f.write(
            f"set_target_properties({name} PROPERTIES CXX_STANDARD 20 "
            "CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n"
        )
        f.write(f"target_compile_options({name} PRIVATE -fno-exceptions)\n")
    else:
        CMAKE_GENERATED_TARGETS_LINK_TYPE[name] = "INTERFACE"
        f.write(f"add_library({name} INTERFACE)\n")
        if hdrs:
            f.write(f"target_sources({name} INTERFACE\n")
            for p in hdrs:
                f.write(f"  {p}\n")
            f.write(")\n")
        f.write(
            f"target_include_directories({name} INTERFACE ${{PROJECT_SOURCE_DIR}})\n"
        )
        f.write(f"target_compile_options({name} INTERFACE -fno-exceptions)\n")


def generate_public_sans() -> None:
    cmake = Path("third_party/public-sans/CMakeLists.txt")
    with cmake.open("w") as f:
        # Enforce a minimum CMake version for this generated subdirectory
        f.write("cmake_minimum_required(VERSION 3.20)\n\n")
        f.write("##\n")
        f.write("## Generated by tools/cmake/gen_cmakelists.py.\n")
        f.write("## NOTE: Do not edit this file directly, edit gen_cmakelists.py instead\n")
        f.write("##\n\n")
        f.write("find_package(Python3 REQUIRED)\n")
        f.write("set(PUBLIC_SANS_FONT ${PROJECT_SOURCE_DIR}/third_party/public-sans/PublicSans-Medium.otf)\n")
        f.write("set(PUBLIC_SANS_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/public-sans)\n")
        f.write("set(PUBLIC_SANS_OUT ${CMAKE_CURRENT_BINARY_DIR}/public-sans/embed_resources)\n")
        f.write("file(MAKE_DIRECTORY ${PUBLIC_SANS_OUT})\n")
        f.write("add_custom_command(\n")
        f.write("  OUTPUT ${PUBLIC_SANS_OUT}/PublicSans_Medium_otf.cpp ${PUBLIC_SANS_OUT}/PublicSansFont.h\n")
        f.write("  COMMAND ${Python3_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/embed_resources.py --out ${PUBLIC_SANS_OUT} --header PublicSansFont.h kPublicSansMediumOtf=${PUBLIC_SANS_FONT}\n")
        f.write("  DEPENDS ${PUBLIC_SANS_FONT} ${PROJECT_SOURCE_DIR}/tools/embed_resources.py\n")
        f.write("  COMMENT \"Embedding Public Sans\"\n")
        f.write("  VERBATIM\n")
        f.write(")\n")
        f.write("add_library(public_sans_font ${PUBLIC_SANS_OUT}/PublicSans_Medium_otf.cpp)\n")
        f.write("target_include_directories(public_sans_font PUBLIC ${PUBLIC_SANS_INCLUDE_DIR})\n")
        f.write("set_target_properties(public_sans_font PROPERTIES CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES POSITION_INDEPENDENT_CODE YES)\n")
        f.write("target_compile_options(public_sans_font PRIVATE -fno-exceptions)\n")


def generate_all_packages() -> None:
    """Emit a CMakeLists.txt for every internal package discovered with bazel."""

    by_pkg: DefaultDict[str, List[Tuple[str, str]]] = DefaultDict(list)
    for kind, label in query_cc_targets():
        pkg, tgt = label.removeprefix("//").split(":", 1)
        if pkg in SKIPPED_PACKAGES:
            continue
        by_pkg[pkg].append((kind, tgt))

    for pkg, entries in by_pkg.items():
        cmake = Path(pkg) / "CMakeLists.txt"
        cmake.parent.mkdir(parents=True, exist_ok=True)
        with cmake.open("w") as f:
            f.write("##\n")
            f.write("## Generated by tools/cmake/gen_cmakelists.py.\n")
            f.write("## NOTE: Do not edit this file directly, edit gen_cmakelists.py instead\n")
            f.write("##\n\n")

            # Enforce a minimum CMake version for this generated subdirectory
            f.write("cmake_minimum_required(VERSION 3.20)\n\n")

            for kind, tgt in sorted(entries):
                bazel_label = f"//{pkg}:{tgt}"
                srcs = query_labels("srcs", bazel_label, relative_to=pkg)
                hdrs = query_labels("hdrs", bazel_label, relative_to=pkg)
                cmake_name = cmake_target_name(pkg, tgt)

                # Target declaration
                if kind == "cc_library":
                    write_library(f, cmake_name, srcs, hdrs)
                else:  # cc_binary / cc_test
                    f.write(f"add_executable({cmake_name}\n")
                    for p in srcs + hdrs:
                        f.write(f"  {p}\n")
                    f.write(")\n")
                    f.write(
                        f"target_include_directories({cmake_name} PRIVATE "
                        "${PROJECT_SOURCE_DIR})\n"
                    )
                    f.write(
                        f"set_target_properties({cmake_name} PROPERTIES "
                        "CXX_STANDARD 20 CXX_STANDARD_REQUIRED YES)\n"
                    )
                    flag = "-fexceptions" if "_with_exceptions" in cmake_name else "-fno-exceptions"
                    f.write(f"target_compile_options({cmake_name} PRIVATE {flag})\n")
                    if kind == "cc_test":
                        f.write(f"add_test(NAME {cmake_name} COMMAND {cmake_name})\n")

                # Link dependencies
                deps = []
                # Special-case examples' SVG binaries to only link against the umbrella 'donner' target
                if pkg == "examples" and kind == "cc_binary" and tgt in ("svg_to_png", "svg_tree_interaction"):
                    f.write(f"target_link_libraries({cmake_name} PRIVATE donner)\n")
                    continue
                for dep in query_deps(bazel_label):
                    mapped = KNOWN_BAZEL_TO_CMAKE_DEPS.get(dep)
                    print(f"Processing dependency: {dep} -> {mapped}")
                    if not mapped and dep.startswith("//"):
                        p, n = dep.removeprefix("//").split(":", 1)
                        mapped = cmake_target_name(p, n)
                    if mapped and mapped != cmake_name:
                        deps.append(mapped)

                if deps:
                    scope = (
                        "PRIVATE"
                        if kind in {"cc_binary", "cc_test"}
                        else (
                            "INTERFACE"
                            if CMAKE_GENERATED_TARGETS_LINK_TYPE.get(cmake_name)
                            == "INTERFACE"
                            else "PUBLIC"
                        )
                    )
                    # Emit each dependency unquoted so CMake can parse multiple targets correctly
                    deps_list = ' '.join(dict.fromkeys(deps))
                    f.write(f"target_link_libraries({cmake_name} {scope} {deps_list})\n")

                # Hand-written tweaks
                if cmake_name == "donner_svg_renderer_skia":
                    if "skia" not in deps:
                        f.write("target_link_libraries(donner_svg_renderer_skia PUBLIC skia)\n")
                    f.write(
                        "target_include_directories(donner_svg_renderer_skia "
                        "PUBLIC ${skia_SOURCE_DIR})\n")
                elif cmake_name == "donner_svg_renderer_skia_deps":
                    if sys.platform == "darwin":
                        f.write(
                            "target_compile_definitions(donner_svg_renderer_skia_deps "
                            "INTERFACE DONNER_USE_CORETEXT)\n")
                    elif sys.platform.startswith("linux"):
                        f.write(
                            "target_compile_definitions(donner_svg_renderer_skia_deps "
                            "INTERFACE DONNER_USE_FREETYPE_WITH_FONTCONFIG)\n")
                        f.write(
                            "target_link_libraries(donner_svg_renderer_skia_deps "
                            "INTERFACE fontconfig)\n")
                    else:
                        f.write(
                            "target_compile_definitions(donner_svg_renderer_skia_deps "
                            "INTERFACE DONNER_USE_FREETYPE)\n")

    #
    # Umbrella INTERFACE target mirroring //:donner
    #
    root = Path("CMakeLists.txt")
    with root.open("a") as f:
        f.write("\n# Umbrella library for external consumers\n")
        f.write("if(NOT TARGET donner)\n")
        f.write("  add_library(donner INTERFACE)\n")
        for dep in query_deps("//:donner"):
            mapped = (
                KNOWN_BAZEL_TO_CMAKE_DEPS.get(dep) if not dep.startswith("//") else
                cmake_target_name(*dep.removeprefix("//").split(":", 1))
            )
            print(f"Processing dependency: {dep} -> {mapped}")
            if mapped and mapped != "donner":
                f.write(f"  target_link_libraries(donner INTERFACE {mapped})\n")
        f.write("endif()\n")


def main() -> None:
    generate_root()        # externals + FetchContent handled here
    generate_public_sans() # font embedder
    generate_all_packages()


if __name__ == "__main__":
    main()
