import subprocess
import os
import argparse
import typing
from dataclasses import dataclass
import sys


@dataclass
class ReportOptions:
    all: bool = False
    binary_size: bool = False
    coverage: bool = False
    public_targets: bool = False
    external_dependencies: bool = False


def run_command(command):
    print("Running command: " + command)
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
    except KeyboardInterrupt:
        print("Interrupted! Exiting...")
        return None

    print("Done, return code: " + str(result.returncode))
    return result.stdout.strip()


def get_git_revision() -> str:
    try:
        revision = (
            subprocess.check_output(["git", "rev-parse", "HEAD"])
            .strip()
            .decode("utf-8")
        )
        return revision
    except subprocess.CalledProcessError:
        return "unknown"


def get_git_status() -> str:
    try:
        status = subprocess.check_output(["git", "status", "--short"]).decode("utf-8")
        return status
    except subprocess.CalledProcessError:
        return "unknown"


def get_bazel_query_command(query: str) -> str:
    return f'bazel query "{query}"'


def query_external_dependencies() -> typing.List[str]:
    query_output = run_command("bazel query 'deps(//examples:svg_to_png)' --keep_going")

    # Find lines beginning with @word// and return unique "word" values
    # (i.e. the external dependencies)
    external_dependencies = set()
    for line in query_output.split("\n"):
        if line.startswith("@"):
            external_dependencies.add(line[1:].split("//")[0])

    # Filter out build-only config: Lines starting with `bazel`, `@bazel`, or `rules_`
    external_dependencies = [
        dep
        for dep in external_dependencies
        if not dep.startswith(
            ("bazel", "@bazel", "rules_", "platforms", "skia_user_config")
        )
    ]

    return external_dependencies


def create_build_report(
    options: ReportOptions, save_svgs_to: typing.Optional[str] = None
):
    report = "# Donner build report\n\n"

    command_line = " ".join(sys.argv)
    report += f"Generated with: {command_line}\n\n"

    revision = get_git_revision()
    report += f"Git revision: [{revision}](https://github.com/jwmcglynn/donner/commit/{revision})\n\n"

    status = get_git_status()
    if status:
        report += "Local changes:\n"
        report += "```\n"
        report += status
        report += "```\n"

    # Lines of code report
    report += "## Lines of code\n```\n"
    report += "$ tools/cloc.sh\n"

    cloc_output = run_command("tools/cloc.sh")
    if not cloc_output:
        return report

    report += cloc_output
    report += "\n```\n\n"

    # Binary size report
    if options.all or options.binary_size:
        report += "## Binary size\n"
        report += "Generated by `tools/binary_size.sh`\n"
        binsize_output = run_command("tools/binary_size.sh")
        if not binsize_output:
            return report

        report += binsize_output

        if save_svgs_to:
            # Copy build-binary-size/binary_size_bargraph.svg into the folder
            # specified by save_svgs_to
            file = os.path.join(save_svgs_to, "binary_size_bargraph.svg")
            with open(file, "w") as f:
                with open("build-binary-size/binary_size_bargraph.svg", "r") as svg:
                    f.write(svg.read())

            report += "\n\n![Binary size bar graph](binary_size_bargraph.svg)"
        report += "\n\n"

    # Code coverage report
    if options.all or options.coverage:
        report += "## Code coverage\n```\n"
        report += "$ tools/coverage.sh --quiet\n"

        coverage_output = run_command("tools/coverage.sh --quiet")
        if not coverage_output:
            return report

        report += coverage_output
        report += "\n```\n\n"

    # Public targets report
    if options.all or options.public_targets:
        report += "## Public targets\n```\n"
        public_targets_cmd = get_bazel_query_command(
            "kind(library, set(//donner/... //:*)) intersect attr(visibility, public, //...)"
        )
        report += f"$ {public_targets_cmd}\n"

        public_targets_output = run_command(public_targets_cmd)
        if not public_targets_output:
            return report

        report += public_targets_output
        report += "\n```\n\n"

    # External dependencies report
    if options.all or options.external_dependencies:
        report += "## External dependencies\n\n"

        external_dependencies = query_external_dependencies()
        for dependency in external_dependencies:
            report += f"- {dependency}\n"
        report += "\n\n"

    return report


def main():
    parser = argparse.ArgumentParser(
        description="Generate a build report for a C++/Bazel project."
    )
    parser.add_argument("--save", type=str, help="Path to save the build report")
    parser.add_argument(
        "--all", action="store_true", help="Generate a full build report"
    )
    parser.add_argument(
        "--binary-size", action="store_true", help="Generate binary size report"
    )
    parser.add_argument(
        "--coverage", action="store_true", help="Generate code coverage report"
    )
    parser.add_argument(
        "--public-targets", action="store_true", help="Generate public targets report"
    )
    parser.add_argument(
        "--external-dependencies",
        action="store_true",
        help="Generate external dependencies report",
    )

    args = parser.parse_args()

    options = ReportOptions(
        all=args.all,
        binary_size=args.binary_size,
        coverage=args.coverage,
        public_targets=args.public_targets,
        external_dependencies=args.external_dependencies,
    )

    report = create_build_report(
        options, save_svgs_to=os.path.dirname(args.save) if args.save else None
    )

    if args.save:
        with open(args.save, "w") as file:
            file.write(report)

        print(f"Saved build report to {args.save}")
    else:
        print(report)


if __name__ == "__main__":
    main()
